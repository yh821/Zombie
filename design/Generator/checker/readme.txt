配置检测规则说明（vertifyConfigRule.json)：

1、ConfigCode：配置表编号映射。
所有待检测的配置表都须列在这里并用唯一编号表示,之后的检测规则使用编号表示具体配置表。

2、Source：被依赖的配置表字段集合。
这里登记了被依赖表的关键字段，这些字段之后会被外部表（Target）所依赖。例如："ruleId": ["2"]，
表示编号为2的配置表ruleId字段会被某张外部表所依赖。具体外部表依赖关系由Target配置。

3、Target：依赖的配置表字段集合。
这里所列出的待检测表中所标识的字段都须在Souce集中被找到。例如："1": {"48":["skill"], "52":["model"]}，
表示编号为1的配置表中skill字段和model字段分别要在Source中48、52号配置表对应的登记字段中找到，否则检测失败。
即：1号表的skill、model字段分别关联了48号表的id、52号表的id字段（具体查阅Source中的登记字段）。

4、Filter：过滤规则。
过滤某些不需要检测的字段数据。例如："48": {"conditionId":["==0"]}，表示48号配置表conditionId值为0时，
不加入检测列表；另一种情况："11": {"monster": ["refreshType !=1"]}，则表示当11号表中refreshType字段不为1时，
过滤掉monster字段数据（注意空格号分割）

5、Mapping：映射规则。
通过表和表之间字段一对一做映射，即保证A表字段a数据在B表字段b中能找到。例如："57": {"id":["4", "id"]}，表示编号为57
的配置表中id字段数据要在编号为4的配置表的id中找到。以上字段均不做键值约束，无须唯一，对原有规则做了拓展性兼容。

6、Sole：字段数据唯一规则：
表的当前检测字段的数据不能出现重复，保证唯一性。例如："3":["id"]，表示编号为3的配置表的id字段的所有数据都是唯一的。

7、Repeated：字段为repeated类型的校验规则。
校验repeated类型字段的数组长度，保证该字段配有足够的数据。例如"65": {"monster_lv":[2], "monster_number":[1]}，表示编号为
65的配置表中，monster_lv和monster_number字段类型必须为repeated，且数组长度必须分别为2和1。

8、Array: 两个数组的长度一致。
校验俩个字段的数组是否相等，这两个字段的关系为对应关系，如A为攻击力属性id，B为对应的攻击力值。例子：
"36" : {"attrs":["36", "values"] } 表示编号为36的表的‘attrs’字段的数组长度 必须与编号36的‘values’字段的数组长度相等。

9、其他特殊检测规则：
不符合以上关联规则的配置表加载和检测的，须在代码中做特殊处理，参考_loadSpecialConfigTarget和_Vertify函数中的逻辑。

